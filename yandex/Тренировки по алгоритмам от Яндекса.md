# Тренировки по алгоритмам от Яндекса

## Лекция 1. Сложность, тестирование, особые случаи

### Что такое сложность?

* Сложность алгоритма - порядок количества действий, которые выполняет алгоритм.

* Например, в программе два вложенных цикла, каждый из которых от 1 до N, тогда сложность составляет **O(N^2)**

* Константы, не зависящие от размера входных данных, не так влияют на скорость работы алгоритма при больших параметрах.

* Ещё бывает пространственная сложность - количество использованной памяти.



Задача №1. Дана строка. Найти самый часто встречающийся в ней символ. Если несколько символов, то выбрать любой.

Решение №1. Переберём все позиции и для каждой позиции в строке ещё раз переберём все позиции и в случае совпадения прибавим счётчику единицу. Найдём максимальное значение счётчика.

```c++
string s;
char ans = '';
size_t max_count = 0;

for(const auto& c1 : s)
{
    size_t count = 0;
    for(const auto& c2 : s)
    {
        if(c1 == c2) ++count;
    }
    if(count > max_count)
    {
        ans = c1;
        max_count = count;
    }
}
```

**T(n) = O(n^2)**

Память: **O(n)**

Решение №2.

Возьмём все уникальные буквы в строке и посчитаем для каждой сколько раз встретилась.

```python
s = input()
ans = ''
anscnt = 0
for now in set(s):
    nowcnt = 0
    for j in range(len(s)):
        if now == s[j]:
            nowcnt += 1
    if nowcnt > anscnt:
        ans = now
        anscnt = nowcnt
print(ans)
```

**T(n) = O(nk)**, где k - число уникальных букв и k <= n

Память: **O(n + k)**

Решение №3.

Заведём словарь, где ключ - символ, а значение - сколько раз он встретился. Если символ встретился впервые - создаём элемент этого символа со значение единица. 

```c++
string s;
char ans = '';
size_t max_count = 0;
unordered_map<char, size_t> count;

for(const auto& c : s)
{
    ++count[c];
}

for(const auto& it : count)
{
    if(max_count < count.second)
    {
        max_count = count.second;
        ans = count.first;
    }
}
```

**T(n) = O(n+k) = O(n)**

Память: **O(k)**

### Особые случаи

Сумма последовательности

```c++
size_t sum = 0;

if(nums.size() == 0) return 0; /// эта строчка лишняя

for(const auto& el : nums)
{
    sum += el;
}

return sum;
```



* Проверять алгоритм следует на крайних случаях. Например, если нужно найти максимум в массиве, то проверить алгоритм на пустом массиве. 



Советы по составлению тестов:

* Если есть примеры - реши их руками и сверь ответы. Если не совпадает, то правильных ответов может быть несколько, либо ты неправильно понял задачу.
* Сначала составь несколько примеров и реши задачу руками, чтобы лучше понять условие и чтобы потом было с чем сравнить.
* Проверь последовательность из одного элемента и пустую последовательность.



Задача №2. Даны три целых числа a, b, c. Найдите все корни уравнения ax^2 + bx + c = 0 и выведите их в порядке возрастания.

Решение: D = b^2 - 4ac; x_1,2 = (-b +- sqrt(D)) / (2 * a)

```python
if a == 0:
    if b != 0:
        print(-c / b)
    if b == 0 and c == 0:
        print('Infinite number of solutions')
else:
    d = b ** 2 - 4 * a * c
    if d == 0:
        x1 = -b / (2 * a)
        print(x1)
    elif d > 0:
        x1 = (-b - sqrt(d)) / (2 * a)
        x2 = (-b + sqrt(d)) / (2 * a)
        if x1 < x2:
            print(x1, x2)
        else:
            print(x2, x1)
```

Этот код обрабатывает все краевые случаи.



## Лекция 2. Линейный поиск

### Классические задачи

* Линейный поиск - способ поиска, когда перебираются все элементы
* Сложность линейного поиска - линейная, т.е. **O(n)**
* Обычно ищут "подходящий" элемент или "наиболее подходящий элемент"

Задача №1. Дана последовательность чисел длины N. Найти первое (левое) вхождение положительного числа X в неё или вывести -1, если число X не встречается.

Решение. Сначала положим в ответ -1, затем перебираем все элементы.

```c++
int find(vector<int>& nums, int X)
{
    int result = -1;
    for(int i = 0; i < N; ++i)
    {
        if(nums[i] == X && result == -1)
        {
            result = i;
            break;
        }
    }
    return result;
}
```

Задача №2. Дана последовательность чисел длины N. Найти последнее (правое) вхождение положительного числа X в неё или вывести -1, если число X не встречается.

```c++
int find(vector<int>& nums, int X)
{
    int result = -1;
    for(int i = N - 1; i >= 0; --i)
    {
        if(nums[i] == X && result == -1)
        {
            result = i;
            break;
        }
    }
    return result;
}
```

Задача №3. Дана последовательность чисел длины N (N > 0). Найти максимальное значение последовательности.

```c++
int find_max(vector<int>& nums)
{
    int max = nums[0]; // или = INT_MIN
    for(int i = 1; i < nums.size(); ++i)
    {
        max = std::max(nums[i], max);
    }
    return max;
}
```

Если вместо чисел надо сравнивать, например, строки, то вместо значения можно использовать индексы в массиве строк.

Задача №4. Дана последовательность чисел длины N (N > 1). Найти максимальное число и второе по величине в последовательности.

Решение. Заведем две переменные для первого и второго максимума. Возьмём первые два числа из последовательности и запишем большее из них в переменную для первого максимум, а меньшее - для второго. Пройдём по всей последовательности. Если очередное число больше первого максимума, то запишем во второй максимум значение первого, а в первый - текущее число. Если только больше второго, запишем текущее число во второй максимум.

```c++
vector<int> find_max2(vector<int>& nums)
{
    int max = INT_MIN;
    int pre_max = INT_MIN;
    
    for(size_t i = 0; i < nums.size(); ++i)
    {
        if(nums[i] > max)
        {
            pre_max = max;
            max = nums[i];
        }
        else if(nums[i] > pre_max)
        {
            pre_max = nums[i];
        }
    }
    return {max, pre_max};
}
```

Задача №5. Дана последовательность чисел длины N. Найти минимальное чётное число в последовательности или вывести -1, если такого не существует. 

Решение.

```c++
int find_min_even(vector<int>& nums)
{
    int min = -1;
    for(int i = 0; i < nums.size(); ++i)
    {
        if(nums[i] % 2 == 0)
        {
            if(min == -1) min = nums[i]; // Если в массиве все числа >= 0, то эта строчка не нужна
            min = std::min(min, nums[i]);
        }
    }
    return min;
}
```

Задача №6. Дана последовательность слов. Вывести все самые короткие слова через пробел.

Решение.

```c++
void shorts_words(vector<string>& words)
{
    int min_len = words[0].size();
    for(int i = 1; i < words.size(); ++i)
    {
        min_len = std::min(min_len, words[i].size());
    }
    
    for(int i = 0; i < words.size(); ++i)
    {
        if(words[i].size() == min_len) 
        {
            cout << words[i];
        }
    }
}
```

Задача №7. Игра PitCraft происходит в двумерном мире, который состоит из блоков размера 1 на 1 метр. Остров игрока представляет собой набор столбцов различной высоты, состоящий из блоков камня и окружённый морем. Над островом прошёл сильный дождь, который заполнил все низины водой, а не поместившаяся в них вода стекла в море, не увеличив уровень.

По ландшафту острова определите, сколько блоков воды осталось в низинах на острове, т.е. определить кол-во синих блоков.

Решение.

```c++
int isleflood(vector<int>& h)
{
    int max_pos = 0;
    for(int i = 0; i < h.size(); ++i)
    {
        if(h[i] > h[max_pos])
        {
            max_pos = i;
        }
    }
    int result = 0;
    int cur_max = 0;
    for(int i = 0; i < max_pos; ++i)
    {
        cur_max = std::max(cur_max, h[i]);
        result += cur_max - h[i];
    }
    cur_max = 0;
    for(int i = h.size() - 1; i > max_pos; --i)
    {
        cur_max = std::max(cur_max, h[i]);
        result += cur_max - h[i];
    }
    
    return result;
}
```

### Задача с собеседования

 Дана строка, состоящая из букв A-Z. Нужно написать функцию RLE, которая преобразует подряд идущим одинаковым символам в пару - букву и число повторений. В случае, если символ единичный, то он остаётся без изменений.



Допустим мы не можем пока решить данную задачу. Тогда можно попробовать упростить её, например, вернуть строку, как в первой задаче, но без числа повторений. AABBACAA -> ABACA

```c++
string easy(string s)
{
    string result;
    char last_sym = s[0];
    for(int i = 1; i < s.size(); ++i)
    {
        if(s[i] != last_sym)
        {
            result.push_back(last_sym;
            last_sym = s[i];
        }
    }
    result += last_sym;
    return result;
}
```

Теперь пробуем решить задачу "потруднее".

```c++
string easy(string s)
{
    string result;
    char last_sym = s[0];
    int last_pos = 0;
    for(int i = 1; i < s.size(); ++i)
    {
        if(s[i] != last_sym)
        {
            result.push_back(last_sym);
            if(i - last_pos > 1) result += std::to_string(i - last_pos);
            last_sym = s[i];
            last_pos = i;
        }
    }
    result.push_back(last_sym);
    if(s.size() - last_pos > 2) result += std::to_string(i - last_pos);
    return result;
}
```







