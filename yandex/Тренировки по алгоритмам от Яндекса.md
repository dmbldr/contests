# Тренировки по алгоритмам от Яндекса

## Лекция 1. Сложность, тестирование, особые случаи

### Что такое сложность?

* Сложность алгоритма - порядок количества действий, которые выполняет алгоритм.

* Например, в программе два вложенных цикла, каждый из которых от 1 до N, тогда сложность составляет **O(N^2)**

* Константы, не зависящие от размера входных данных, не так влияют на скорость работы алгоритма при больших параметрах.

* Ещё бывает пространственная сложность - количество использованной памяти.



Задача №1. Дана строка. Найти самый часто встречающийся в ней символ. Если несколько символов, то выбрать любой.

Решение №1. Переберём все позиции и для каждой позиции в строке ещё раз переберём все позиции и в случае совпадения прибавим счётчику единицу. Найдём максимальное значение счётчика.

```c++
string s;
char ans = '';
size_t max_count = 0;

for(const auto& c1 : s)
{
    size_t count = 0;
    for(const auto& c2 : s)
    {
        if(c1 == c2) ++count;
    }
    if(count > max_count)
    {
        ans = c1;
        max_count = count;
    }
}
```

**T(n) = O(n^2)**

Память: **O(n)**

Решение №2.

Возьмём все уникальные буквы в строке и посчитаем для каждой сколько раз встретилась.

```python
s = input()
ans = ''
anscnt = 0
for now in set(s):
    nowcnt = 0
    for j in range(len(s)):
        if now == s[j]:
            nowcnt += 1
    if nowcnt > anscnt:
        ans = now
        anscnt = nowcnt
print(ans)
```

**T(n) = O(nk)**, где k - число уникальных букв и k <= n

Память: **O(n + k)**

Решение №3.

Заведём словарь, где ключ - символ, а значение - сколько раз он встретился. Если символ встретился впервые - создаём элемент этого символа со значение единица. 

```c++
string s;
char ans = '';
size_t max_count = 0;
unordered_map<char, size_t> count;

for(const auto& c : s)
{
    ++count[c];
}

for(const auto& it : count)
{
    if(max_count < count.second)
    {
        max_count = count.second;
        ans = count.first;
    }
}
```

**T(n) = O(n+k) = O(n)**

Память: **O(k)**

### Особые случаи

Сумма последовательности

```c++
size_t sum = 0;

if(nums.size() == 0) return 0; /// эта строчка лишняя

for(const auto& el : nums)
{
    sum += el;
}

return sum;
```



* Проверять алгоритм следует на крайних случаях. Например, если нужно найти максимум в массиве, то проверить алгоритм на пустом массиве. 



Советы по составлению тестов:

* Если есть примеры - реши их руками и сверь ответы. Если не совпадает, то правильных ответов может быть несколько, либо ты неправильно понял задачу.
* Сначала составь несколько примеров и реши задачу руками, чтобы лучше понять условие и чтобы потом было с чем сравнить.
* Проверь последовательность из одного элемента и пустую последовательность.



Задача №2. Даны три целых числа a, b, c. Найдите все корни уравнения ax^2 + bx + c = 0 и выведите их в порядке возрастания.

Решение: D = b^2 - 4ac; x_1,2 = (-b +- sqrt(D)) / (2 * a)

```python
if a == 0:
    if b != 0:
        print(-c / b)
    if b == 0 and c == 0:
        print('Infinite number of solutions')
else:
    d = b ** 2 - 4 * a * c
    if d == 0:
        x1 = -b / (2 * a)
        print(x1)
    elif d > 0:
        x1 = (-b - sqrt(d)) / (2 * a)
        x2 = (-b + sqrt(d)) / (2 * a)
        if x1 < x2:
            print(x1, x2)
        else:
            print(x2, x1)
```

Этот код обрабатывает все краевые случаи.



## Домашнее задание к лекции 1

### Дивизион B

#### ДЗ 1

[Задания](https://contest.yandex.ru/contest/28730/enter/)

Решения:

A. Interactor

```c++
#include <iostream>

int main()
{
	int r, i, c;

	std::cin >> r >> i >> c;

	if(i == 6)
    {
    	std::cout << 0;
    	return 0;
    }
    if(i == 7)
    {
        std::cout << 1;
        return 0;
    }

	if(i == 1)
    {
    	std::cout << c;
    	return 0;
    }

	if((i == 0 || i == 4) && r != 0)
    {
        std::cout << 3;
		return 0;
    }
	
	if(i == 0 || i == 1)
    {
    	std::cout << c;
    	return 0;
    }
	
	std::cout << i;

	return 0;
}
```

B. Кольцевая линия метро

```c++
#include <iostream>
#include <cmath>

int main()
{
	int N, i, j;

	std::cin >> N >> i >> j;
	

	uint16_t first = abs(j - i) - 1;
	
	if(i > j) std::swap(i, j);
	
	uint16_t second = N - j + i - 1;

	std::cout << std::min(first, second);

	return 0;
}
```

C. Даты

```c++
#include <iostream>

int main()
{
    int x, y, z;
    std::cin >> x >> y >> z;
    
	if(x == y)
    {
    	std::cout << 1;
   		return 0;
    }
    if(x <= 12 && y <= 12)
    {
        std::cout << 0;
        return 0;
    }
    std::cout << 1;
   	return 0;
}
```

В данной задаче я не понимаю почему, если x == y, то тогда дату можно однозначно определить... Например, на вход поступила строка 2 2 2003. Почему в данном случае мы можем однозначно определить дату....

D. Строительство школы

```c++
#include <bits/stdc++.h>

int main()
{
    int N;
    std::cin >> N;
 	std::vector<int> coord(N);
    
	for(int i = 0; i < N; ++i)
    {
    	std::cin >> coord[i];
    }
	
	std::cout << coord[N / 2];
}
```

Изначально я решал эту задачу, беря среднее по всем координатам. Но это была ошибка. Например, для координат домов 1, 99, 100 в моём случае ответ был бы 67. Ключевая фраза тут "суммарное расстояние, которое проезжают ученики от своих домов до школы, было минимально."

E. Точка и треугольник

```c++


```



#### ДЗ 2

A. Кол-во равных максимальному

```c++
#include <bits/stdc++.h>

int main()
{
	std::vector<uint32_t> nums;
	
	uint32_t tmp = 0;
	uint32_t max_num = 0;
	
	while(true)
    {
    	std::cin >> tmp;
    	if(tmp == 0) break;
    	nums.push_back(tmp);
    	max_num = std::max(tmp, max_num);
    }

	for(const auto& num : nums)
    {
    	if(num == max_num)
        {
        	++tmp;
        }
    }

	std::cout << tmp;
}
```

B. Дома и магазины

```c++
#include <bits/stdc++.h>

int main()
{
	int tmp;
	int min_val = 11;
	int max_val = 0;
	std::vector<int> markets;
	std::vector<int> houses;
	for(int i = 0; i < 10; ++i)
    {
    	std::cin >> tmp;
    	if(tmp == 2) markets.push_back(i);
    	if(tmp == 1) houses.push_back(i);
    }
	
	for(const auto& house : houses)
    {
    	for(const auto& market : markets)
        {
        	min_val = std::min(std::abs(market - house), min_val); 
        }
    	max_val = std::max(min_val, max_val);
    	min_val = 11;
    }

	std::cout << max_val;
}
```

C. Изготовление палиндромов

```c++


```



### Дивизион A

#### ДЗ 1

#### ДЗ 2











